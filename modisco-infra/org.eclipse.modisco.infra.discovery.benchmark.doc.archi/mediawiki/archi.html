<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="Functional_view">Functional view</h1><h2 id="Functional_requirements">Functional requirements</h2><ul><li>we want to be able to determine the (time and memory) performance of any discoverer</li><li>we want to be able to understand its memory behavior depending on its state (opening a model, running a transformation, etc.)</li><li>we want to be able to determine the fraction of the whole discovery time spent saving</li><li>we want to be able to compare several implementations of the same discoverer</li></ul><h2 id="Functional_analysis">Functional analysis</h2><p>The benchmarking will take place on a PC with random unaccountable activity from the OS or other programs. So, in order to obtain the most reliable result, we need to do several measurements.</p><p>=&gt; The user can choose how many times to run each discovery</p><p>We want to know which parts of the discovery take the most time or memory. So, we need a way to see what the benchmark is doing at any time. For this, we choose to emit events (analyzing file x, discovering package y, saving file z, etc.).</p><p>=&gt; The benchmark must be able to record discoverer events happening while it is running</p><h2 id="Functional_architecture">Functional architecture</h2><h3 id="Functional_data">Functional data</h3><p><img border="0" src="../img/benchmark.png"/></p><p>A benchmark consists of one or more discoveries launched on one or more projects. Each unique discovery is launched on a single project.
The same discovery can be executed several times, so that averages and standard deviations can be computed.
Some data is associated with each benchmark : the memory settings of the JVM, the hardware configuration on which the benchmark was run, and the operating system that was used.</p><p>Each project has a name (the name of the Eclipse project), and a list of the files it contains that were actually discovered. For each file, we memorize its filepath, its size in bytes, and the number of lines it contains. And the project computes the sum of the number of lines from all the files it contains, the average file size, the average number of lines per file, and the sum of the number of bytes of each contained file.</p><p>A discovery has the following information in the metamodel :</p><ul><li>its name</li><li>the variant of the discovery algorithm if applicable</li><li>the ID of the MoDisco discoverer</li><li>the name of the class that implements the discoverer</li><li>the variant of the metamodel that is used to save the discovered model, if applicable</li><li>the number of model elements that were saved by the discoverer</li><li>the size of the XMI file that was saved by the discoverer</li></ul><p>And each discovery iteration has:</p><ul><li>the date of the discovery</li><li>the discovery time in seconds</li><li>the save time in seconds</li><li>the maximum number of bytes allocated to the JVM process during the discovery</li><li>a list of error messages (with stacktrace if possible) if errors happened during the discovery</li></ul><p>Each discovery iteration can contain a list of memory measurements and of events that happened during the discovery and save.
Each memory measurement has a timestamp and a measure of how much memory (in MiB) was in use at that time.
An event has a timestamp, and each event can be either a standard event or an event marking the beginning or the end of some action.
Each end event must be linked to a beginning event, so that we can measure a time span for an action.
Each event has a type, with a name that determines what this event represents, and a boolean indicating whether the event occurred during the saving part of the discovery.</p><h3 id="Functional_components">Functional components</h3><p><img border="0" src="../img/functional_components.png"/></p><p>A discoverer benchmark references the discoverer it must launch and the launch configuration for this discoverer (containing the discovery parameters), the number of iterations it must be run, whether to generate the HTML report at the end of the benchmark, whether to measure memory use, and the memory polling interval if applicable. It also has a file filter, that determines which files constitute the input of the discovery, in order to get benchmark metrics that correspond to what was really analyzed.</p><p>The benchmark has an event and memory recorder, on which measurements can be started and stopped, with or without memory measurements. It memorizes the start and stop times, the maximum memory used, the individual memory measurements (each measurement consisting of the amount of memory allocated at a given time), and a list of events that happened during the benchmark. Each event has a time and a type. The event types are returned by the discoverer through the IEventNotifier interface, which it also uses to accept listeners (i.e. : the event and memory recorder) that will record the events.</p><h1 id="Technical_view">Technical view</h1><h2 id="Technical_requirements">Technical requirements</h2><p>The benchmark has the following requirements :</p><ul><li>The user has to be able to benchmark any MoDisco discoverer from any public source code management system</li><li>The user has to be able to run a benchmark from the command line, without any user interaction</li><li>The user can generate an HTML benchmark report from a benchmark model</li></ul><h2 id="Technical_analysis">Technical analysis</h2><p>A benchmark is supposed to be able to be left unattended, for example during the night or over the course of several days. So, it means the user shouldn't have to regularly come back and select another project to launch it on.</p><p>=&gt; The user has to be able to run a benchmark on several projects in a row</p><p>It also means the benchmark should not crash :</p><p>=&gt; Errors should be logged and must not cause the benchmark to abort</p><p>And even in case it does crash or must be terminated for some other reason, we would still like to get partial results :</p><p>=&gt; Intermediate results should be saved</p><p>We would like to get usable results as fast as possible, and avoid running out of memory at the beginning of the discovery :</p><p>=&gt; The benchmark should order the projects it runs the discoverer on from smallest to biggest</p><p>Due to the nature of the JVM the memory use varies greatly, in a roller-coaster fashion : it goes up when objects are allocated, and when it reaches a certain threshold, the garbage collector (GC) kicks in and brings the memory use back down again. So, the memory measurements must be taken immediately after the GC has run, in order to know the "real" memory use. And since we want to be able to have regular measurements, we have to run the GC ourselves. This has the drawback that the performance suffers a lot from manually running the GC often. So, we cannot have an accurate measure of the duration of the discovery while simultaneously measuring memory use : we must choose between accurate time measurements and accurate memory measurements.</p><p>=&gt; The user can choose whether to measure memory use during the discovery</p><p>With discoveries of big projects using a lot of memory, the GC can take a few seconds to do a single pass. So, running it every few milliseconds could multiply the overall time by a factor of 100 or more. So, we have to choose between regular measurements, and a benchmark that terminates in a reasonable amount of time.</p><p>=&gt; The user can choose how often the memory measurements are taken</p><h2 id="Technical_architecture">Technical architecture</h2><p>The data beans are implemented with EMF (there is a data model).</p><p>We choose to implement the benchmark as a discoverer, first because it makes sense since the benchmark creates a benchmark model as a result. And because it provides several facilities that are useful for the benchmark :</p><ul><li>an easy way to define parameters through annotations</li><li>a user interface for entering parameters (with associated serialization) through existing cell editors, and launching a discovery</li><li>a well defined and documented programmatic interface</li><li>facilities for creating a model on AbstractModelDiscoverer&lt;?&gt;</li></ul><p>The benchmark can only be run on a discoverer that takes an Eclipse project as input (i.e : a class that extends AbstractModelDiscoverer&lt;IProject&gt;).</p><p>We want to generate diagrams for showing the time and memory behaviors. We will use Birt for this, since it is the only Eclipse project that is capable of doing this.</p><p>In case the benchmark crashes or must be terminated for some other reason, we would still like to get partial results. To ensure this, we catch all exceptions happening during a discovery (even potential OutOfMemoryError's), and save the results and generate the report in all cases.&#xc;</p><h1 id="Applicative_view">Applicative view</h1><p><img border="0" src="../img/applicative_view.png"/></p><p>The benchmark is defined as a discoverer, with several parameters to control the benchmarking process : </p><ul><li>the number of iterations to run</li><li>whether to measure memory use</li><li>how often to measure the memory use</li><li>whether to generate the HTML report at the end of the benchmark</li><li>which discoverer to launch</li><li>the launch configuration for the discoverer</li></ul><h2 id="EventAndMemoryRecorder">EventAndMemoryRecorder</h2><p>The EventAndMemoryRecorder class is used to measure the memory use during a discovery, by the means of a Job that runs in the background, and regularly ("memoryPollingInterval") calls the garbage collector and then immediately measures the memory used.</p><h3 id="Event_recorder">Event recorder</h3><p>The discoverer can implement IEventNotifier, so that it may notify events during the discovery (for showing steps, or more generally "things" that happen during the discovery) by calling notifyEvent(Event) on the IEventListener it received through the interface IEventNotifier.</p><p>The discoverer can implement the listener mechanism, or delegate to the IEventManager which can be created through IEventManagerFactory.</p><p>In any case, the events should be dispatched to all listeners, the EventAndMemoryRecorder always being one such listener.</p><p><img border="0" src="../img/event_recorder.png"/></p><p>At the beginning of the benchmark, before starting the discoverer, the benchmark hooks up the event and memory recorder so that it listens to the discoverer events and starts the memory measurements.</p><p>The benchmark then launches the discoverer.</p><p>The discoverer starts doing its work. During this process, it may call notifyEvent(Event) on its listeners (the EventAndMemoryRecorder) before and/or after each major step it performs.</p><p>At the end of the benchmark â€” once the discoverer is finished â€” the benchmark removes the listener, stops the memory measurements, and retrieves the events and memory measurements.</p><h2 id="Plug-in_Architecture">Plug-in Architecture</h2><p>The benchmarking tool is implemented in six main plug-ins. The global plug-in architecture is shown on the next figure.</p><p><img border="0" src="../img/architecture.png"/></p><h2 id="user_interface">user interface</h2><p>The benchmark can be launched either by clicking through the Eclipse UI, or headlessly from the command line.</p><ul><li>By creating an Eclipse launch configuration</li><li>By running an Eclipse application in command line</li></ul><h3 id="GUI_launching">GUI launching</h3><p>To start the benchmark from the UI using the Eclipse launch configuration system:
<!--* using the context menu :</p><ul><li><ul><li>right-click on a set of projects and select "MoDisco &gt; Discovery &gt; Benchmark"</li><li>this opens a first parameters dialog used to enter parameters specific to the benchmark itself : the discoverer to benchmark, the number of iterations to perform, whether to measure memory use during discovery, and which interval to use between memory measurements</li><li>fill in the benchmark parameters, especially the DISCOVERER_ID field</li><li>open the discoverer parameters dialog by clicking in the field named "DISCOVERER_LAUNCH_CONFIGURATION" (this dialog can only be opened after setting the DISCOVERER_ID field).</li><li>in this second dialog, fill in the discoverer parameters and then click OK</li><li>click OK in the first dialog to launch the benchmark --></li></ul></li></ul><ul><li>Create a new MoDisco launch configuration</li></ul><p><img border="0" src="../img/LaunchConfig1.png"/></p><ul><li>Select the benchmark discoverer (org.eclipse.modisco.infra.discovery.benchmark.api.benchmarkdiscoverer)</li><li>Select the projects to use with the discoverers</li></ul><p><img border="0" src="../img/LaunchConfig2Projects.png"/></p><ul><li>Select the discovers to benchmark</li></ul><p><img border="0" src="../img/LaunchConfig3DiscovererList.png"/></p><ul><li>When you press OK, dialog windows will appear to set up the parameters specific for each discoverers </li></ul><p><img border="0" src="../img/LaunchConfig4DiscovererParam.png"/></p><ul><li>Set the value of the benchmark parameter</li><li>The launch configuration is ready to be launched.</li></ul><p><!--The DISCOVERER_ID field has type DiscovererID. A cell editor will be created for this type, so that it is possible to choose a discoverer among the existing ones.
A DiscovererID encapsulates a String with the additional constraint that it must correspond to the ID of an existing MoDisco discoverer. --></p><p><!--The DISCOVERER_LAUNCH_CONFIGURATION field has type LaunchConfiguration. A cell editor will be created for this type, so that it is possible to edit a discoverer launch configuration as a parameter of another launch configuration (the benchmark's launch configuration).--></p><p><!--The DISCOVERER_ID parameter is redundant with the ID contained in the DISCOVERER_LAUNCH_CONFIGURATION, but it is nonetheless necessary because the discoverer must be chosen by the user before the second dialog can be constructed to edit the discoverer parameters.--></p><p><!--<img border="0" src="../img/launching.png"/>--></p><p><!--To launch a benchmark, the user starts by selecting projects to benchmark. Then they open the benchmark discoverer from the MoDisco menu.
The benchmark will start by retrieving the selection, and then opens a parameters dialog in order to choose the benchmark parameters.
The user then fills in those parameters (or leaves the default values as they were for optional parameters).
Once the discoverer to benchmark is chosen, the user can open the parameters dialog for this discoverer by clicking on the "..." button in the "discovererLaunchConfig" field.
The benchmark component will then retrieve the formal parameters for this discoverer, and create a dialog to let the user enter values for these parameters.
Once the user has chosen the parameters and closed this second dialog, they can then launch the benchmark by clicking OK.--></p><h3 id="Headless_launching">Headless launching</h3><p>When run in headless (command line) mode (for example on a CI server such as Hudson), we pass the name of a launch configuration containing the parameters for the benchmark. This is done this way in order to avoid having to pass many parameters on the command line. Thus, a workspace should exist before launching the benchmark, and it should contain a benchmark launch configuration. We use Buckminster to materialize this workspace containing all the projects to benchmark, and the project containing the benchmark launch configuration.</p><h2 id="FileFilter_declaration">FileFilter declaration</h2><p><img border="0" src="../img/file_filter.png"/></p><p>In order to get metrics relevant to the benchmark, a "benchmark configuration" extension point is provided. It allows specifying which files among all the files contained in the project are really worked on by the discoverer. If no extension is provided for a discoverer, the discoverer can still be benchmarked, but the metrics will be imprecise.</p></body></html>