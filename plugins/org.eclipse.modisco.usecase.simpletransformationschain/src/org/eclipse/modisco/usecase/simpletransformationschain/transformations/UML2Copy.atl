-- @atlcompiler atl2006
-- $Id: UML2Copy.atl 7380 2007-11-08 09:49:02Z dwagelaa $
-- Copies UML2 models
module UML2Copy;

create umlOutput : uml from umlInput : uml;

helper def : inElements : Set(uml!"ecore::EObject") = uml!"ecore::EObject".allInstancesFrom('umlInput');

entrypoint rule init() {
	do {
		-- just here to allow superimposition of entrypoint
	}
}
-- ======================================================================
-- Ecore copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 7249 2007-09-11 09:34:31Z dwagelaa

rule EAnnotation {
    from s : uml!"ecore::EAnnotation" (thisModule.inElements->includes(s))
    to t : uml!"ecore::EAnnotation" mapsTo s (
        source <- s.source,
        eAnnotations <- s.eAnnotations,
        details <- s.details,
        contents <- s.contents,
        references <- s.references)
}

rule EStringToStringMapEntry {
    from s : uml!"ecore::EStringToStringMapEntry" (thisModule.inElements->includes(s))
    to t : uml!"ecore::EStringToStringMapEntry" mapsTo s (
        key <- s.key,
        value <- s.value)
}

-- ======================================================================
-- Ecore copying rules end
-- ======================================================================

-- ======================================================================
-- uml copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 7249 2007-09-11 09:34:31Z dwagelaa

rule Comment {
    from s : uml!"uml::Comment" (thisModule.inElements->includes(s))
    to t : uml!"uml::Comment" mapsTo s (
        body <- s.body,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        annotatedElement <- s.annotatedElement)
}

rule Package {
    from s : uml!"uml::Package" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Package")
		else false endif)
    to t : uml!"uml::Package" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication)
}

rule Dependency {
    from s : uml!"uml::Dependency" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Dependency")
		else false endif)
    to t : uml!"uml::Dependency" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule ElementImport {
    from s : uml!"uml::ElementImport" (thisModule.inElements->includes(s))
    to t : uml!"uml::ElementImport" mapsTo s (
        visibility <- s.visibility,
        alias <- s.alias,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedElement <- s.importedElement)
}

rule PackageImport {
    from s : uml!"uml::PackageImport" (thisModule.inElements->includes(s))
    to t : uml!"uml::PackageImport" mapsTo s (
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedPackage <- s.importedPackage)
}

rule Constraint {
    from s : uml!"uml::Constraint" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Constraint")
		else false endif)
    to t : uml!"uml::Constraint" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule Association {
    from s : uml!"uml::Association" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Association")
		else false endif)
    to t : uml!"uml::Association" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule TemplateBinding {
    from s : uml!"uml::TemplateBinding" (thisModule.inElements->includes(s))
    to t : uml!"uml::TemplateBinding" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        signature <- s.signature,
        parameterSubstitution <- s.parameterSubstitution)
}

rule TemplateSignature {
    from s : uml!"uml::TemplateSignature" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::TemplateSignature")
		else false endif)
    to t : uml!"uml::TemplateSignature" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter)
}

rule TemplateParameter {
    from s : uml!"uml::TemplateParameter" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::TemplateParameter")
		else false endif)
    to t : uml!"uml::TemplateParameter" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule TemplateParameterSubstitution {
    from s : uml!"uml::TemplateParameterSubstitution" (thisModule.inElements->includes(s))
    to t : uml!"uml::TemplateParameterSubstitution" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        formal <- s.formal,
        actual <- s.actual,
        ownedActual <- s.ownedActual)
}

rule Generalization {
    from s : uml!"uml::Generalization" (thisModule.inElements->includes(s))
    to t : uml!"uml::Generalization" mapsTo s (
        isSubstitutable <- s.isSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        general <- s.general,
        generalizationSet <- s.generalizationSet)
}

rule GeneralizationSet {
    from s : uml!"uml::GeneralizationSet" (thisModule.inElements->includes(s))
    to t : uml!"uml::GeneralizationSet" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isCovering <- s.isCovering,
        isDisjoint <- s.isDisjoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        powertype <- s.powertype,
        generalization <- s.generalization)
}

rule Substitution {
    from s : uml!"uml::Substitution" (thisModule.inElements->includes(s))
    to t : uml!"uml::Substitution" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        contract <- s.contract)
}

rule Realization {
    from s : uml!"uml::Realization" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Realization")
		else false endif)
    to t : uml!"uml::Realization" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping)
}

rule Abstraction {
    from s : uml!"uml::Abstraction" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Abstraction")
		else false endif)
    to t : uml!"uml::Abstraction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping)
}

rule OpaqueExpression {
    from s : uml!"uml::OpaqueExpression" (thisModule.inElements->includes(s))
    to t : uml!"uml::OpaqueExpression" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        behavior <- s.behavior)
}

rule Parameter {
    from s : uml!"uml::Parameter" (thisModule.inElements->includes(s))
    to t : uml!"uml::Parameter" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        direction <- s.direction,
        isException <- s.isException,
        isStream <- s.isStream,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        templateParameter <- s.templateParameter,
        end <- s.end,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        parameterSet <- s.parameterSet,
        defaultValue <- s.defaultValue)
}

rule ConnectorEnd {
    from s : uml!"uml::ConnectorEnd" (thisModule.inElements->includes(s))
    to t : uml!"uml::ConnectorEnd" mapsTo s (
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        partWithPort <- s.partWithPort,
        role <- s.role)
}

rule Property {
    from s : uml!"uml::Property" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Property")
		else false endif)
    to t : uml!"uml::Property" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        end <- s.end,
        deployment <- s.deployment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier)
}

rule Deployment {
    from s : uml!"uml::Deployment" (thisModule.inElements->includes(s))
    to t : uml!"uml::Deployment" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        deployedArtifact <- s.deployedArtifact,
        configuration <- s.configuration)
}

rule DeploymentSpecification {
    from s : uml!"uml::DeploymentSpecification" (thisModule.inElements->includes(s))
    to t : uml!"uml::DeploymentSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        fileName <- s.fileName,
        deploymentLocation <- s.deploymentLocation,
        executionLocation <- s.executionLocation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        nestedArtifact <- s.nestedArtifact,
        manifestation <- s.manifestation,
        ownedOperation <- s.ownedOperation,
        ownedAttribute <- s.ownedAttribute)
}

rule Artifact {
    from s : uml!"uml::Artifact" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Artifact")
		else false endif)
    to t : uml!"uml::Artifact" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        fileName <- s.fileName,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        nestedArtifact <- s.nestedArtifact,
        manifestation <- s.manifestation,
        ownedOperation <- s.ownedOperation,
        ownedAttribute <- s.ownedAttribute)
}

rule Manifestation {
    from s : uml!"uml::Manifestation" (thisModule.inElements->includes(s))
    to t : uml!"uml::Manifestation" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        utilizedElement <- s.utilizedElement)
}

rule Operation {
    from s : uml!"uml::Operation" (thisModule.inElements->includes(s))
    to t : uml!"uml::Operation" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        ownedParameter <- s.ownedParameter,
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        redefinedOperation <- s.redefinedOperation,
        bodyCondition <- s.bodyCondition)
}

rule Class {
    from s : uml!"uml::Class" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Class")
		else false endif)
    to t : uml!"uml::Class" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception)
}

rule InterfaceRealization {
    from s : uml!"uml::InterfaceRealization" (thisModule.inElements->includes(s))
    to t : uml!"uml::InterfaceRealization" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        contract <- s.contract)
}

rule Interface {
    from s : uml!"uml::Interface" (thisModule.inElements->includes(s))
    to t : uml!"uml::Interface" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier,
        redefinedInterface <- s.redefinedInterface,
        ownedReception <- s.ownedReception,
        protocol <- s.protocol)
}

rule Reception {
    from s : uml!"uml::Reception" (thisModule.inElements->includes(s))
    to t : uml!"uml::Reception" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        ownedParameter <- s.ownedParameter,
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        signal <- s.signal)
}

rule Signal {
    from s : uml!"uml::Signal" (thisModule.inElements->includes(s))
    to t : uml!"uml::Signal" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute)
}

rule ProtocolStateMachine {
    from s : uml!"uml::ProtocolStateMachine" (thisModule.inElements->includes(s))
    to t : uml!"uml::ProtocolStateMachine" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        region <- s.region,
        submachineState <- s.submachineState,
        connectionPoint <- s.connectionPoint,
        extendedStateMachine <- s.extendedStateMachine,
        conformance <- s.conformance)
}

rule StateMachine {
    from s : uml!"uml::StateMachine" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::StateMachine")
		else false endif)
    to t : uml!"uml::StateMachine" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        region <- s.region,
        submachineState <- s.submachineState,
        connectionPoint <- s.connectionPoint,
        extendedStateMachine <- s.extendedStateMachine)
}

rule Region {
    from s : uml!"uml::Region" (thisModule.inElements->includes(s))
    to t : uml!"uml::Region" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        subvertex <- s.subvertex,
        transition <- s.transition,
        extendedRegion <- s.extendedRegion)
}

rule Transition {
    from s : uml!"uml::Transition" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Transition")
		else false endif)
    to t : uml!"uml::Transition" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        target <- s.target,
        redefinedTransition <- s.redefinedTransition,
        guard <- s.guard,
        effect <- s.effect,
        trigger <- s.trigger,
        source <- s.source)
}

rule Trigger {
    from s : uml!"uml::Trigger" (thisModule.inElements->includes(s))
    to t : uml!"uml::Trigger" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        event <- s.event,
        port <- s.port)
}

rule Port {
    from s : uml!"uml::Port" (thisModule.inElements->includes(s))
    to t : uml!"uml::Port" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        isBehavior <- s.isBehavior,
        isService <- s.isService,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        end <- s.end,
        deployment <- s.deployment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier,
        redefinedPort <- s.redefinedPort,
        protocol <- s.protocol)
}

rule State {
    from s : uml!"uml::State" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::State")
		else false endif)
    to t : uml!"uml::State" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        submachine <- s.submachine,
        connection <- s.connection,
        connectionPoint <- s.connectionPoint,
        redefinedState <- s.redefinedState,
        stateInvariant <- s.stateInvariant,
        entry <- s.entry,
        exit <- s.exit,
        doActivity <- s.doActivity,
        deferrableTrigger <- s.deferrableTrigger,
        region <- s.region)
}

rule ConnectionPointReference {
    from s : uml!"uml::ConnectionPointReference" (thisModule.inElements->includes(s))
    to t : uml!"uml::ConnectionPointReference" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        entry <- s.entry,
        exit <- s.exit)
}

rule Pseudostate {
    from s : uml!"uml::Pseudostate" (thisModule.inElements->includes(s))
    to t : uml!"uml::Pseudostate" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming)
}

rule ProtocolConformance {
    from s : uml!"uml::ProtocolConformance" (thisModule.inElements->includes(s))
    to t : uml!"uml::ProtocolConformance" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        generalMachine <- s.generalMachine)
}

rule Connector {
    from s : uml!"uml::Connector" (thisModule.inElements->includes(s))
    to t : uml!"uml::Connector" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        redefinedConnector <- s.redefinedConnector,
        end <- s.end,
        contract <- s.contract)
}

rule Extension {
    from s : uml!"uml::Extension" (thisModule.inElements->includes(s))
    to t : uml!"uml::Extension" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule ExtensionEnd {
    from s : uml!"uml::ExtensionEnd" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExtensionEnd" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        end <- s.end,
        deployment <- s.deployment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier)
}

rule Image {
    from s : uml!"uml::Image" (thisModule.inElements->includes(s))
    to t : uml!"uml::Image" mapsTo s (
        content <- s.content,
        location <- s.location,
        format <- s.format,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment)
}

rule Model {
    from s : uml!"uml::Model" (thisModule.inElements->includes(s))
    to t : uml!"uml::Model" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        viewpoint <- s.viewpoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication)
}

rule ParameterSet {
    from s : uml!"uml::ParameterSet" (thisModule.inElements->includes(s))
    to t : uml!"uml::ParameterSet" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        parameter <- s.parameter,
        condition <- s.condition)
}

rule DataType {
    from s : uml!"uml::DataType" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::DataType")
		else false endif)
    to t : uml!"uml::DataType" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation)
}

rule OperationTemplateParameter {
    from s : uml!"uml::OperationTemplateParameter" (thisModule.inElements->includes(s))
    to t : uml!"uml::OperationTemplateParameter" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule ConnectableElementTemplateParameter {
    from s : uml!"uml::ConnectableElementTemplateParameter" (thisModule.inElements->includes(s))
    to t : uml!"uml::ConnectableElementTemplateParameter" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule CollaborationUse {
    from s : uml!"uml::CollaborationUse" (thisModule.inElements->includes(s))
    to t : uml!"uml::CollaborationUse" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        roleBinding <- s.roleBinding)
}

rule Collaboration {
    from s : uml!"uml::Collaboration" (thisModule.inElements->includes(s))
    to t : uml!"uml::Collaboration" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        collaborationRole <- s.collaborationRole)
}

rule UseCase {
    from s : uml!"uml::UseCase" (thisModule.inElements->includes(s))
    to t : uml!"uml::UseCase" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        include <- s.include,
        extend <- s.extend,
        extensionPoint <- s.extensionPoint,
        subject <- s.subject)
}

rule Include {
    from s : uml!"uml::Include" (thisModule.inElements->includes(s))
    to t : uml!"uml::Include" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        addition <- s.addition)
}

rule Extend {
    from s : uml!"uml::Extend" (thisModule.inElements->includes(s))
    to t : uml!"uml::Extend" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        extendedCase <- s.extendedCase,
        condition <- s.condition,
        extensionLocation <- s.extensionLocation)
}

rule ExtensionPoint {
    from s : uml!"uml::ExtensionPoint" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExtensionPoint" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression)
}

rule RedefinableTemplateSignature {
    from s : uml!"uml::RedefinableTemplateSignature" (thisModule.inElements->includes(s))
    to t : uml!"uml::RedefinableTemplateSignature" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter,
        extendedSignature <- s.extendedSignature)
}

rule ClassifierTemplateParameter {
    from s : uml!"uml::ClassifierTemplateParameter" (thisModule.inElements->includes(s))
    to t : uml!"uml::ClassifierTemplateParameter" mapsTo s (
        allowSubstitutable <- s.allowSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        --defaultClassifier <- s.defaultClassifier,
        constrainingClassifier <- s.constrainingClassifier)
}

rule StringExpression {
    from s : uml!"uml::StringExpression" (thisModule.inElements->includes(s))
    to t : uml!"uml::StringExpression" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        operand <- s.operand,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        subExpression <- s.subExpression)
}

rule Expression {
    from s : uml!"uml::Expression" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Expression")
		else false endif)
    to t : uml!"uml::Expression" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        operand <- s.operand)
}

rule PackageMerge {
    from s : uml!"uml::PackageMerge" (thisModule.inElements->includes(s))
    to t : uml!"uml::PackageMerge" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        mergedPackage <- s.mergedPackage)
}

rule ProfileApplication {
    from s : uml!"uml::ProfileApplication" (thisModule.inElements->includes(s))
    to t : uml!"uml::ProfileApplication" mapsTo s (
        isStrict <- s.isStrict,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        appliedProfile <- s.appliedProfile)
}

rule Enumeration {
    from s : uml!"uml::Enumeration" (thisModule.inElements->includes(s))
    to t : uml!"uml::Enumeration" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
        ownedLiteral <- s.ownedLiteral)
}

rule EnumerationLiteral {
    from s : uml!"uml::EnumerationLiteral" (thisModule.inElements->includes(s))
    to t : uml!"uml::EnumerationLiteral" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        deployment <- s.deployment,
        templateParameter <- s.templateParameter,
        classifier <- s.classifier,
        slot <- s.slot,
        specification <- s.specification)
}

rule InstanceSpecification {
    from s : uml!"uml::InstanceSpecification" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::InstanceSpecification")
		else false endif)
    to t : uml!"uml::InstanceSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        deployment <- s.deployment,
        templateParameter <- s.templateParameter,
        classifier <- s.classifier,
        slot <- s.slot,
        specification <- s.specification)
}

rule Slot {
    from s : uml!"uml::Slot" (thisModule.inElements->includes(s))
    to t : uml!"uml::Slot" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        definingFeature <- s.definingFeature,
        value <- s.value)
}

rule PrimitiveType {
    from s : uml!"uml::PrimitiveType" (thisModule.inElements->includes(s))
    to t : uml!"uml::PrimitiveType" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation)
}

rule LiteralInteger {
    from s : uml!"uml::LiteralInteger" (thisModule.inElements->includes(s))
    to t : uml!"uml::LiteralInteger" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralString {
    from s : uml!"uml::LiteralString" (thisModule.inElements->includes(s))
    to t : uml!"uml::LiteralString" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralBoolean {
    from s : uml!"uml::LiteralBoolean" (thisModule.inElements->includes(s))
    to t : uml!"uml::LiteralBoolean" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralNull {
    from s : uml!"uml::LiteralNull" (thisModule.inElements->includes(s))
    to t : uml!"uml::LiteralNull" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule InstanceValue {
    from s : uml!"uml::InstanceValue" (thisModule.inElements->includes(s))
    to t : uml!"uml::InstanceValue" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        instance <- s.instance)
}

rule LiteralUnlimitedNatural {
    from s : uml!"uml::LiteralUnlimitedNatural" (thisModule.inElements->includes(s))
    to t : uml!"uml::LiteralUnlimitedNatural" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule OpaqueBehavior {
    from s : uml!"uml::OpaqueBehavior" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::OpaqueBehavior")
		else false endif)
    to t : uml!"uml::OpaqueBehavior" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule FunctionBehavior {
    from s : uml!"uml::FunctionBehavior" (thisModule.inElements->includes(s))
    to t : uml!"uml::FunctionBehavior" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule OpaqueAction {
    from s : uml!"uml::OpaqueAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::OpaqueAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        inputValue <- s.inputValue,
        outputValue <- s.outputValue)
}

rule StructuredActivityNode {
    from s : uml!"uml::StructuredActivityNode" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::StructuredActivityNode")
		else false endif)
    to t : uml!"uml::StructuredActivityNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node)
}

rule Activity {
    from s : uml!"uml::Activity" (thisModule.inElements->includes(s))
    to t : uml!"uml::Activity" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        isReadOnly <- s.isReadOnly,
        isSingleExecution <- s.isSingleExecution,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        variable <- s.variable,
        node <- s.node,
        edge <- s.edge,
        partition <- s.partition,
        group <- s.group)
}

rule Variable {
    from s : uml!"uml::Variable" (thisModule.inElements->includes(s))
    to t : uml!"uml::Variable" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        templateParameter <- s.templateParameter,
        end <- s.end,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule ActivityPartition {
    from s : uml!"uml::ActivityPartition" (thisModule.inElements->includes(s))
    to t : uml!"uml::ActivityPartition" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isDimension <- s.isDimension,
        isExternal <- s.isExternal,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        node <- s.node,
        subpartition <- s.subpartition,
        represents <- s.represents,
        edge <- s.edge)
}

rule InterruptibleActivityRegion {
    from s : uml!"uml::InterruptibleActivityRegion" (thisModule.inElements->includes(s))
    to t : uml!"uml::InterruptibleActivityRegion" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        node <- s.node,
        interruptingEdge <- s.interruptingEdge)
}

rule ExceptionHandler {
    from s : uml!"uml::ExceptionHandler" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExceptionHandler" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        handlerBody <- s.handlerBody,
        exceptionInput <- s.exceptionInput,
        exceptionType <- s.exceptionType)
}

rule OutputPin {
    from s : uml!"uml::OutputPin" (thisModule.inElements->includes(s))
    to t : uml!"uml::OutputPin" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule Pin {
    from s : uml!"uml::Pin" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Pin")
		else false endif)
    to t : uml!"uml::Pin" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule InputPin {
    from s : uml!"uml::InputPin" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::InputPin")
		else false endif)
    to t : uml!"uml::InputPin" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule SendSignalAction {
    from s : uml!"uml::SendSignalAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::SendSignalAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        target <- s.target,
        signal <- s.signal)
}

rule CallOperationAction {
    from s : uml!"uml::CallOperationAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::CallOperationAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        operation <- s.operation,
        target <- s.target)
}

rule CallBehaviorAction {
    from s : uml!"uml::CallBehaviorAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::CallBehaviorAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        behavior <- s.behavior)
}

rule SequenceNode {
    from s : uml!"uml::SequenceNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::SequenceNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        executableNode <- s.executableNode)
}

rule Usage {
    from s : uml!"uml::Usage" (thisModule.inElements->includes(s))
    to t : uml!"uml::Usage" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule ControlFlow {
    from s : uml!"uml::ControlFlow" (thisModule.inElements->includes(s))
    to t : uml!"uml::ControlFlow" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        source <- s.source,
        target <- s.target,
        redefinedEdge <- s.redefinedEdge,
        inPartition <- s.inPartition,
        guard <- s.guard,
        weight <- s.weight,
        interrupts <- s.interrupts)
}

rule InitialNode {
    from s : uml!"uml::InitialNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::InitialNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule ActivityParameterNode {
    from s : uml!"uml::ActivityParameterNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::ActivityParameterNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        parameter <- s.parameter)
}

rule ValuePin {
    from s : uml!"uml::ValuePin" (thisModule.inElements->includes(s))
    to t : uml!"uml::ValuePin" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        value <- s.value)
}

rule Message {
    from s : uml!"uml::Message" (thisModule.inElements->includes(s))
    to t : uml!"uml::Message" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        messageSort <- s.messageSort,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        receiveEvent <- s.receiveEvent,
        sendEvent <- s.sendEvent,
        connector <- s.connector,
        argument <- s.argument)
}

rule Interaction {
    from s : uml!"uml::Interaction" (thisModule.inElements->includes(s))
    to t : uml!"uml::Interaction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        lifeline <- s.lifeline,
        fragment <- s.fragment,
        action <- s.action,
        formalGate <- s.formalGate,
        message <- s.message)
}

rule Lifeline {
    from s : uml!"uml::Lifeline" (thisModule.inElements->includes(s))
    to t : uml!"uml::Lifeline" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        represents <- s.represents,
        selector <- s.selector,
        decomposedAs <- s.decomposedAs,
        coveredBy <- s.coveredBy)
}

rule PartDecomposition {
    from s : uml!"uml::PartDecomposition" (thisModule.inElements->includes(s))
    to t : uml!"uml::PartDecomposition" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        refersTo <- s.refersTo,
        actualGate <- s.actualGate,
        argument <- s.argument)
}

rule InteractionUse {
    from s : uml!"uml::InteractionUse" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::InteractionUse")
		else false endif)
    to t : uml!"uml::InteractionUse" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        refersTo <- s.refersTo,
        actualGate <- s.actualGate,
        argument <- s.argument)
}

rule Gate {
    from s : uml!"uml::Gate" (thisModule.inElements->includes(s))
    to t : uml!"uml::Gate" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        message <- s.message)
}

rule GeneralOrdering {
    from s : uml!"uml::GeneralOrdering" (thisModule.inElements->includes(s))
    to t : uml!"uml::GeneralOrdering" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        before <- s.before,
        after <- s.after)
}

rule OccurrenceSpecification {
    from s : uml!"uml::OccurrenceSpecification" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::OccurrenceSpecification")
		else false endif)
    to t : uml!"uml::OccurrenceSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter)
}

rule InteractionOperand {
    from s : uml!"uml::InteractionOperand" (thisModule.inElements->includes(s))
    to t : uml!"uml::InteractionOperand" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        guard <- s.guard,
        fragment <- s.fragment)
}

rule InteractionConstraint {
    from s : uml!"uml::InteractionConstraint" (thisModule.inElements->includes(s))
    to t : uml!"uml::InteractionConstraint" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        minint <- s.minint,
        maxint <- s.maxint)
}

rule StateInvariant {
    from s : uml!"uml::StateInvariant" (thisModule.inElements->includes(s))
    to t : uml!"uml::StateInvariant" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        invariant <- s.invariant)
}

rule ActionExecutionSpecification {
    from s : uml!"uml::ActionExecutionSpecification" (thisModule.inElements->includes(s))
    to t : uml!"uml::ActionExecutionSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        start <- s.start,
        finish <- s.finish,
        action <- s.action)
}

rule BehaviorExecutionSpecification {
    from s : uml!"uml::BehaviorExecutionSpecification" (thisModule.inElements->includes(s))
    to t : uml!"uml::BehaviorExecutionSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        start <- s.start,
        finish <- s.finish,
        behavior <- s.behavior)
}

rule ExecutionEvent {
    from s : uml!"uml::ExecutionEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExecutionEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule CreationEvent {
    from s : uml!"uml::CreationEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::CreationEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule DestructionEvent {
    from s : uml!"uml::DestructionEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::DestructionEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule SendOperationEvent {
    from s : uml!"uml::SendOperationEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::SendOperationEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule SendSignalEvent {
    from s : uml!"uml::SendSignalEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::SendSignalEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule MessageOccurrenceSpecification {
    from s : uml!"uml::MessageOccurrenceSpecification" (thisModule.inElements->includes(s))
    to t : uml!"uml::MessageOccurrenceSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter,
        message <- s.message)
}

rule ExecutionOccurrenceSpecification {
    from s : uml!"uml::ExecutionOccurrenceSpecification" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExecutionOccurrenceSpecification" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter,
        execution <- s.execution)
}

rule ReceiveOperationEvent {
    from s : uml!"uml::ReceiveOperationEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReceiveOperationEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule ReceiveSignalEvent {
    from s : uml!"uml::ReceiveSignalEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReceiveSignalEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule Actor {
    from s : uml!"uml::Actor" (thisModule.inElements->includes(s))
    to t : uml!"uml::Actor" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger)
}

rule CallEvent {
    from s : uml!"uml::CallEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::CallEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule ChangeEvent {
    from s : uml!"uml::ChangeEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::ChangeEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        changeExpression <- s.changeExpression)
}

rule SignalEvent {
    from s : uml!"uml::SignalEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::SignalEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule AnyReceiveEvent {
    from s : uml!"uml::AnyReceiveEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::AnyReceiveEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule ForkNode {
    from s : uml!"uml::ForkNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::ForkNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule FlowFinalNode {
    from s : uml!"uml::FlowFinalNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::FlowFinalNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule CentralBufferNode {
    from s : uml!"uml::CentralBufferNode" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::CentralBufferNode")
		else false endif)
    to t : uml!"uml::CentralBufferNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection)
}

rule MergeNode {
    from s : uml!"uml::MergeNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::MergeNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule DecisionNode {
    from s : uml!"uml::DecisionNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::DecisionNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        decisionInput <- s.decisionInput)
}

rule ActivityFinalNode {
    from s : uml!"uml::ActivityFinalNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::ActivityFinalNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule ComponentRealization {
    from s : uml!"uml::ComponentRealization" (thisModule.inElements->includes(s))
    to t : uml!"uml::ComponentRealization" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        realizingClassifier <- s.realizingClassifier)
}

rule Component {
    from s : uml!"uml::Component" (thisModule.inElements->includes(s))
    to t : uml!"uml::Component" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        packagedElement <- s.packagedElement,
        realization <- s.realization)
}

rule Node {
    from s : uml!"uml::Node" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Node")
		else false endif)
    to t : uml!"uml::Node" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule Device {
    from s : uml!"uml::Device" (thisModule.inElements->includes(s))
    to t : uml!"uml::Device" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule ExecutionEnvironment {
    from s : uml!"uml::ExecutionEnvironment" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExecutionEnvironment" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule CommunicationPath {
    from s : uml!"uml::CommunicationPath" (thisModule.inElements->includes(s))
    to t : uml!"uml::CommunicationPath" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule CombinedFragment {
    from s : uml!"uml::CombinedFragment" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::CombinedFragment")
		else false endif)
    to t : uml!"uml::CombinedFragment" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        interactionOperator <- s.interactionOperator,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        operand <- s.operand,
        cfragmentGate <- s.cfragmentGate)
}

rule Continuation {
    from s : uml!"uml::Continuation" (thisModule.inElements->includes(s))
    to t : uml!"uml::Continuation" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        setting <- s.setting,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering)
}

rule ConsiderIgnoreFragment {
    from s : uml!"uml::ConsiderIgnoreFragment" (thisModule.inElements->includes(s))
    to t : uml!"uml::ConsiderIgnoreFragment" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        interactionOperator <- s.interactionOperator,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        operand <- s.operand,
        cfragmentGate <- s.cfragmentGate,
        message <- s.message)
}

rule CreateObjectAction {
    from s : uml!"uml::CreateObjectAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::CreateObjectAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        classifier <- s.classifier,
        result <- s.result)
}

rule DestroyObjectAction {
    from s : uml!"uml::DestroyObjectAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::DestroyObjectAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isDestroyLinks <- s.isDestroyLinks,
        isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        target <- s.target)
}

rule TestIdentityAction {
    from s : uml!"uml::TestIdentityAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::TestIdentityAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        first <- s.first,
        second <- s.second,
        result <- s.result)
}

rule ReadSelfAction {
    from s : uml!"uml::ReadSelfAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadSelfAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result)
}

rule ReadStructuralFeatureAction {
    from s : uml!"uml::ReadStructuralFeatureAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadStructuralFeatureAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        result <- s.result)
}

rule ClearStructuralFeatureAction {
    from s : uml!"uml::ClearStructuralFeatureAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ClearStructuralFeatureAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object)
}

rule RemoveStructuralFeatureValueAction {
    from s : uml!"uml::RemoveStructuralFeatureValueAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::RemoveStructuralFeatureValueAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isRemoveDuplicates <- s.isRemoveDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        value <- s.value,
        removeAt <- s.removeAt)
}

rule AddStructuralFeatureValueAction {
    from s : uml!"uml::AddStructuralFeatureValueAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::AddStructuralFeatureValueAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        value <- s.value,
        insertAt <- s.insertAt)
}

rule LinkEndData {
    from s : uml!"uml::LinkEndData" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::LinkEndData")
		else false endif)
    to t : uml!"uml::LinkEndData" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier)
}

rule QualifierValue {
    from s : uml!"uml::QualifierValue" (thisModule.inElements->includes(s))
    to t : uml!"uml::QualifierValue" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        qualifier <- s.qualifier,
        value <- s.value)
}

rule ReadLinkAction {
    from s : uml!"uml::ReadLinkAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadLinkAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue,
        result <- s.result)
}

rule LinkEndCreationData {
    from s : uml!"uml::LinkEndCreationData" (thisModule.inElements->includes(s))
    to t : uml!"uml::LinkEndCreationData" mapsTo s (
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier,
        insertAt <- s.insertAt)
}

rule CreateLinkAction {
    from s : uml!"uml::CreateLinkAction" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::CreateLinkAction")
		else false endif)
    to t : uml!"uml::CreateLinkAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue)
}

rule DestroyLinkAction {
    from s : uml!"uml::DestroyLinkAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::DestroyLinkAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue)
}

rule LinkEndDestructionData {
    from s : uml!"uml::LinkEndDestructionData" (thisModule.inElements->includes(s))
    to t : uml!"uml::LinkEndDestructionData" mapsTo s (
        isDestroyDuplicates <- s.isDestroyDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier,
        destroyAt <- s.destroyAt)
}

rule ClearAssociationAction {
    from s : uml!"uml::ClearAssociationAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ClearAssociationAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        association <- s.association)
}

rule BroadcastSignalAction {
    from s : uml!"uml::BroadcastSignalAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::BroadcastSignalAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        signal <- s.signal)
}

rule SendObjectAction {
    from s : uml!"uml::SendObjectAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::SendObjectAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        target <- s.target,
        request <- s.request)
}

rule ValueSpecificationAction {
    from s : uml!"uml::ValueSpecificationAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ValueSpecificationAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        value <- s.value,
        result <- s.result)
}

rule TimeExpression {
    from s : uml!"uml::TimeExpression" (thisModule.inElements->includes(s))
    to t : uml!"uml::TimeExpression" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        expr <- s.expr,
        observation <- s.observation)
}

rule Duration {
    from s : uml!"uml::Duration" (thisModule.inElements->includes(s))
    to t : uml!"uml::Duration" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        expr <- s.expr,
        observation <- s.observation)
}

rule DurationInterval {
    from s : uml!"uml::DurationInterval" (thisModule.inElements->includes(s))
    to t : uml!"uml::DurationInterval" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule Interval {
    from s : uml!"uml::Interval" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::Interval")
		else false endif)
    to t : uml!"uml::Interval" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule TimeConstraint {
    from s : uml!"uml::TimeConstraint" (thisModule.inElements->includes(s))
    to t : uml!"uml::TimeConstraint" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule IntervalConstraint {
    from s : uml!"uml::IntervalConstraint" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::IntervalConstraint")
		else false endif)
    to t : uml!"uml::IntervalConstraint" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule TimeInterval {
    from s : uml!"uml::TimeInterval" (thisModule.inElements->includes(s))
    to t : uml!"uml::TimeInterval" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule DurationConstraint {
    from s : uml!"uml::DurationConstraint" (thisModule.inElements->includes(s))
    to t : uml!"uml::DurationConstraint" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule TimeObservation {
    from s : uml!"uml::TimeObservation" (thisModule.inElements->includes(s))
    to t : uml!"uml::TimeObservation" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        event <- s.event)
}

rule DurationObservation {
    from s : uml!"uml::DurationObservation" (thisModule.inElements->includes(s))
    to t : uml!"uml::DurationObservation" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        event <- s.event)
}

rule FinalState {
    from s : uml!"uml::FinalState" (thisModule.inElements->includes(s))
    to t : uml!"uml::FinalState" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        submachine <- s.submachine,
        connection <- s.connection,
        connectionPoint <- s.connectionPoint,
        redefinedState <- s.redefinedState,
        stateInvariant <- s.stateInvariant,
        entry <- s.entry,
        exit <- s.exit,
        doActivity <- s.doActivity,
        deferrableTrigger <- s.deferrableTrigger,
        region <- s.region)
}

rule TimeEvent {
    from s : uml!"uml::TimeEvent" (thisModule.inElements->includes(s))
    to t : uml!"uml::TimeEvent" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isRelative <- s.isRelative,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        when <- s.when)
}

rule ReadVariableAction {
    from s : uml!"uml::ReadVariableAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadVariableAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        result <- s.result)
}

rule ClearVariableAction {
    from s : uml!"uml::ClearVariableAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ClearVariableAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable)
}

rule AddVariableValueAction {
    from s : uml!"uml::AddVariableValueAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::AddVariableValueAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        value <- s.value,
        insertAt <- s.insertAt)
}

rule RemoveVariableValueAction {
    from s : uml!"uml::RemoveVariableValueAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::RemoveVariableValueAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isRemoveDuplicates <- s.isRemoveDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        value <- s.value,
        removeAt <- s.removeAt)
}

rule RaiseExceptionAction {
    from s : uml!"uml::RaiseExceptionAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::RaiseExceptionAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        exception <- s.exception)
}

rule ActionInputPin {
    from s : uml!"uml::ActionInputPin" (thisModule.inElements->includes(s))
    to t : uml!"uml::ActionInputPin" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        fromAction <- s.fromAction)
}

rule InformationItem {
    from s : uml!"uml::InformationItem" (thisModule.inElements->includes(s))
    to t : uml!"uml::InformationItem" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        represented <- s.represented)
}

rule InformationFlow {
    from s : uml!"uml::InformationFlow" (thisModule.inElements->includes(s))
    to t : uml!"uml::InformationFlow" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        realization <- s.realization,
        conveyed <- s.conveyed,
        informationSource <- s.informationSource,
        informationTarget <- s.informationTarget,
        realizingActivityEdge <- s.realizingActivityEdge,
        realizingConnector <- s.realizingConnector,
        realizingMessage <- s.realizingMessage)
}

rule ReadExtentAction {
    from s : uml!"uml::ReadExtentAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadExtentAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        classifier <- s.classifier)
}

rule ReclassifyObjectAction {
    from s : uml!"uml::ReclassifyObjectAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReclassifyObjectAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        oldClassifier <- s.oldClassifier,
        newClassifier <- s.newClassifier,
        object <- s.object)
}

rule ReadIsClassifiedObjectAction {
    from s : uml!"uml::ReadIsClassifiedObjectAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadIsClassifiedObjectAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isDirect <- s.isDirect,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        classifier <- s.classifier,
        result <- s.result,
        object <- s.object)
}

rule StartClassifierBehaviorAction {
    from s : uml!"uml::StartClassifierBehaviorAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::StartClassifierBehaviorAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object)
}

rule ReadLinkObjectEndAction {
    from s : uml!"uml::ReadLinkObjectEndAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadLinkObjectEndAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        end <- s.end,
        result <- s.result)
}

rule ReadLinkObjectEndQualifierAction {
    from s : uml!"uml::ReadLinkObjectEndQualifierAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReadLinkObjectEndQualifierAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        result <- s.result,
        qualifier <- s.qualifier)
}

rule CreateLinkObjectAction {
    from s : uml!"uml::CreateLinkObjectAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::CreateLinkObjectAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue,
        result <- s.result)
}

rule AcceptEventAction {
    from s : uml!"uml::AcceptEventAction" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(uml!"uml::AcceptEventAction")
		else false endif)
    to t : uml!"uml::AcceptEventAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isUnmarshall <- s.isUnmarshall,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        trigger <- s.trigger)
}

rule AcceptCallAction {
    from s : uml!"uml::AcceptCallAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::AcceptCallAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isUnmarshall <- s.isUnmarshall,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        trigger <- s.trigger,
        returnInformation <- s.returnInformation)
}

rule ReplyAction {
    from s : uml!"uml::ReplyAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReplyAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        replyToCall <- s.replyToCall,
        returnInformation <- s.returnInformation,
        replyValue <- s.replyValue)
}

rule UnmarshallAction {
    from s : uml!"uml::UnmarshallAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::UnmarshallAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        unmarshallType <- s.unmarshallType,
        object <- s.object)
}

rule ReduceAction {
    from s : uml!"uml::ReduceAction" (thisModule.inElements->includes(s))
    to t : uml!"uml::ReduceAction" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isOrdered <- s.isOrdered,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        reducer <- s.reducer,
        result <- s.result,
        collection <- s.collection)
}

rule JoinNode {
    from s : uml!"uml::JoinNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::JoinNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isCombineDuplicate <- s.isCombineDuplicate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        joinSpec <- s.joinSpec)
}

rule DataStoreNode {
    from s : uml!"uml::DataStoreNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::DataStoreNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection)
}

rule ObjectFlow {
    from s : uml!"uml::ObjectFlow" (thisModule.inElements->includes(s))
    to t : uml!"uml::ObjectFlow" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isMulticast <- s.isMulticast,
        isMultireceive <- s.isMultireceive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        source <- s.source,
        target <- s.target,
        redefinedEdge <- s.redefinedEdge,
        inPartition <- s.inPartition,
        guard <- s.guard,
        weight <- s.weight,
        interrupts <- s.interrupts,
        transformation <- s.transformation,
        selection <- s.selection)
}

rule ConditionalNode {
    from s : uml!"uml::ConditionalNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::ConditionalNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        isDeterminate <- s.isDeterminate,
        isAssured <- s.isAssured,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        clause <- s.clause,
        result <- s.result)
}

rule Clause {
    from s : uml!"uml::Clause" (thisModule.inElements->includes(s))
    to t : uml!"uml::Clause" mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        test <- s.test,
        body <- s.body,
        predecessorClause <- s.predecessorClause,
        successorClause <- s.successorClause,
        decider <- s.decider,
        bodyOutput <- s.bodyOutput)
}

rule LoopNode {
    from s : uml!"uml::LoopNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::LoopNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        isTestedFirst <- s.isTestedFirst,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        bodyPart <- s.bodyPart,
        setupPart <- s.setupPart,
        decider <- s.decider,
        test <- s.test,
        result <- s.result,
        loopVariable <- s.loopVariable,
        bodyOutput <- s.bodyOutput,
        loopVariableInput <- s.loopVariableInput)
}

rule ExpansionNode {
    from s : uml!"uml::ExpansionNode" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExpansionNode" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        regionAsOutput <- s.regionAsOutput,
        regionAsInput <- s.regionAsInput)
}

rule ExpansionRegion {
    from s : uml!"uml::ExpansionRegion" (thisModule.inElements->includes(s))
    to t : uml!"uml::ExpansionRegion" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        mode <- s.mode,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        inputElement <- s.inputElement,
        outputElement <- s.outputElement)
}

rule ProtocolTransition {
    from s : uml!"uml::ProtocolTransition" (thisModule.inElements->includes(s))
    to t : uml!"uml::ProtocolTransition" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        target <- s.target,
        redefinedTransition <- s.redefinedTransition,
        guard <- s.guard,
        effect <- s.effect,
        trigger <- s.trigger,
        source <- s.source,
        postCondition <- s.postCondition,
        preCondition <- s.preCondition)
}

rule AssociationClass {
    from s : uml!"uml::AssociationClass" (thisModule.inElements->includes(s))
    to t : uml!"uml::AssociationClass" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

-- ======================================================================
-- uml copying rules end
-- ======================================================================
